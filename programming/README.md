# Programming 예상 질문

### Overloading과 Overriding에 대해서 설명해주세요

<details>

오버로딩은 같은 클래스 내에 같은 이름의 메소드를 여러 개 정의하는 것을 말합니다. 예로 출력으로 System.out.println 같은 것들이 있습니다.
오버로딩을 정의할 때 매개 변수 타입이나, 개수, 위치가 달라야 합니다.
오버라이딩은 부모 클래스로부터 물려받은 메소드의 내용을 자식 클래스에게 맞게 변경하는 것을 말합니다. 예를 들어 equals와 같은 메소드를 원활한 비교를 만들어내기 위해 오버라이딩해서 수정하는 것을 말합니다.

</details>

### API, Libaray, Framework를 설명해주세요

<details>

API는 시스템이 제공하는 기능을 제어할 수 있게 만든 인터페이스입니다.
라이브러리는 시스템 개발에 있어서 반복되거나 유용한 함수들을 모아놓은 집합체를 말합니다.
프레임워크는 시스템 개발을 쉽게 하기 위해서 여러 라이브러리를 포함하고 전반적인 인프라 환경을 제공하는 것이 프레임워크입니다.

</details>

### API, Libaray, Framework를 차이점을 말해주세요

<details>

API는 구현체라고 보기보다는 구현된 시스템의 사용 방법, 즉 인터페이스 역할이 된다. 반면 라이브러리는 구현체가 존재하게 됩니다.
라이브러리와 프레임워크는 흐름 주도권을 누가 가지고 있냐입니다.
라이브러리는 필요할 때 가져다가 쓰면 되지만 프레임워크는 처음부터 프레임워크가 제공하는 개발 환경 위에서 개발하기 때문에 수동적이라고 볼 수 있습니다.

</details>

### call by value, call by reference에 대해서 설명해주세요

<details>

call by value는 메소드 호출 시에 인자에 있는 데이터를 복사해서 전달하는 것이고 call by refence는 인자의 메모리 주소 값을 그대로 전달하는 것을 말합니다.
그래서 call by value는 서로 다른 값이 함수 내에서 값 변경이 일어나더라도 기존 변수는 값의 변화가 없습니다. 하지만 call by refence는 주소를 가져가기 때문에 같은 주소를 가르키기 때문에 함수 내부에서 값을 변경하게 되면 함수 밖에 있는 변수의 값도 변경되게 됩니다.

</details>

### 자바는 객체를 전달할 때 call by reference 인가요?

<details>

자바는 레퍼런스 타입을 전달할 때 call by refence라고 하기에는 애매합니다.
레퍼런스 타입의 주소를 그대로 전달하는 것이 아닌 오리진 주소를 가르키는 새로운 메모리 공간을 만들어 그 주소를 전달하게 됩니다.
이렇게 되면 기존 call by refence와의 차이점은 그냥 값을 바꾸는 것에는 차이점이 없고 만약 새로운 레퍼런스 객체를 만들어 할당을 한다면 기존은 그 객체 주소로 변경이 되겠지만 자바는 새로운 메모리 공간의 주소가 새로운 레퍼런스 객체의 주소가 됩니다.

</details>

### 동시성과 병렬성에 대해서 설명해주세요

<details>

동시성이란 동시에 일을 처리하는 것처럼 보이게 하는 것을 말합니다. 싱글 코어가 멀티 스레드 환경에서 각각의 task가 cpu를 번갈아 할당받아 빠른 속도로 번갈아 여러 작업을 처리하는 것을 말합니다.
병렬성이란 실제로 동시에 여러 작업을 처리하는 것을 말합니다. 싱글 코어가 아닌 멀티 코어가 멀티 스레드 환경에서 각각의 task가 하나의 cpu를 할당받아 동시에 작업을 처리하는 것을 말합니다.

</details>

### 동기, 비동기의 차이점을 설명해주세요

<details>

동기 방식과 비동기 방식의 차이점은 return 값을 받기를 기다리냐 안기다려냐에 차이점이 있습니다.
동기 방식은 어떤 함수를 호출시키고 그 함수를 return가 전달될 때까지 함수가 마무리될 때까지 기다리게 됩니다.
그렇기에 동기 방식은 현재 함수 리턴 값이 다음 프로세스에 영향을 미칠 때 사용하거나 높은 CPU와 메모리를 처리하는 경우라면 동기 방식을 이용해야 합니다.
반면 비동기 방식은 어떤 함수를 호출시키고 return값 반환과 상관없이 콜백함수만 주고 다음 작업을 진행하게 됩니다.
비동기는 리턴 값이 필요 없거나 CPU와 메모리를 많이 사용하지 않는 라이트한 작업을 처리할 때 비동기를 많이 사용합니다. 이유는 CPU와 메모리를 많이 차지하는 작업을 비동기로 진행했을 때 과부화가 걸릴 수 있기 때문입니다.
즉 적은 리소스를 필요로 하는 요청을 처리하는데 동기 방식을 이용하면 단위 시간당 처리할 수 있는 요청이 적기 때문에 비동기로 진행하는 것이 좋고 그럴 필요가 없거나 리소스 많이 요구하는 경우 동기 방식을 이용하는 것이 좋습니다.

</details>

### 논블로킹, 블로킹 차이점을 설명해주세요

<details>

블로킹은 대상의 작업이 끝날 때까지 제어권을 계속해서 가지고 있는 것을 말하고 논블로킹을 작업이 끝나지 않았음에도 제어권을 전달해 새로운 작업을 하는 것을 말합니다.

</details>

### 동기, 비동기 & 논블로킹, 블로킹 각각 조합에 대해서 설명해주세요

<details>

동기 블로킹은 함수가 마무리 될 때까지 제어권을 가지고 있고 return 값을 기다리게 됩니다.
비동기 논블로킹은 호출과 동시에 제어권을 넘겨주고 return 값은 신경 쓰지 않고 콜백함수에 전달하게 됩니다.
동기 논블로킹은 polling 방식이라고 볼 수 있습니다. 제어권을 받아 다른 작업을 수행할 수 있지만 계속해서 함수가 끝나길 return 값을 반환받기를 신경 써야 합니다.
비동기 블로킹은 제어권을 주지 않고 return 값을 신경 쓰지 않고 콜백함수에 전달하지만 이 방식은 이점이 없기에 쓰지 않습니다.

예시로 친구에게 어떤 것을 물어보려고 한다면
전화를 해서 바로 물어보는 것을 : 동기 블록킹
이메일을 보내 답이 올 때까지 다른 일을 하며 기다림 : 비동기 논블로킹
친구가 바로 전화를 받지 않아 다른 일을 하면서 계속해서 전화를 거는 상황 : 동기 논블로킹
친구가 바로 전화를 받지 않아 가만히 기다리면 전화를 올 때까지 기다림 : 비동기 블로킹

</details>

### OverHead가 무엇인가요?

<details>

어떤 로직을 처리하기 위해서 간접적으로 들어가는 시간과 메모리를 말합니다.

</details>
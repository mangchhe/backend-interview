# 자료구조 & 알고리즘 예상 질문

### Stack과 Queue에 대해서 설명해주세요

<details>

Stack은 FILO(First In Last Out) 방식인 먼저 들어온 것이 나중에 나오는 구조로 비커에 공을 넣고 위에서 하나씩 꺼내는 것과 같습니다.
Queue는 FIFO(First In First Out) 방식인 먼저 들어온 것이 먼저 나가는 구조로 배수관이 있으면 물이 입구로 먼저 들어오면 먼저 출구로 나오는 것과 같습니다.

</details>

### 배열은 왜 연속적으로 데이터를 할당한다고 생각하나요?

<details>

캐시 메모리에 공간 지역성을 이용하기 위함이라고 생각합니다. ArrayList와 같은 연속적인 배열을 사용할 때 선형 탐색을 조회하는 경우가 많기 때문에 메모리가 여기저기 분산되어 있는 것보다 연속적으로 있는 것이 캐시를 이용해 성능 이점을 얻을 수 있습니다.

</details>

### 배열과 연결리스트 공통점은 무엇인가요?

<details>

동적으로 데이터를 추가 및 삭제를 할 수 있다는 공통점이 있습니다.

</details>

### 배열과 연결리스트의 차이점은 무엇인가요?

<details>

ArrayList는 연속적인 메모리 공간을 가지는 배열이고 LinkedList는 불 규칙적인 메모리 공간을 가지는 배열입니다. 그래서 LinkedList는 각각의 노드가 다음 노드를 가리키는 주소를 담고 있어야 하기 때문에 추가적인 메모리 공간이 필요하게 됩니다.
대신 ArrayList는 값을 중간에 추가하거나 삭제하게 되면 메모리 공간을 연속적으로 유지해야 하기 때문에 O(N)이 걸리는 반면 LinkedList는 추가 삭제 시에 앞에 있는 주소만 빼려고 하는 다음 주소로 연결하면 되기 때문에 O(1)이 걸리게 됩니다.

</details>

### 이중 연결리스트에 대해서 설명해주세요

<details>

이중 연결리스트는 일반 연결리스트와 다르게 다음 노드를 가리키는 주소만 있는 것이 아니라 해당 노드의 앞에 있는 노드의 주소까지 담고 있기 때문에 좀 더 저장 공간은 많이 사용하지만, 앞뒤로 조회가 가능한 구조입니다.
이렇게 되면 끝부분에 있는 값을 조회하기 위해서 앞부분부터 타고 들어가지 않고 뒤에서부터 시작할 수 있기 때문에 탐색 시간을 줄일 수 있다는 장점이 있습니다. 단점은 앞에서 말했듯이 저장공간이 더 많이 들게 됩니다.

</details>

### 원형 연결리스트에 대해서 설명해주세요

<details>

원형 연결리스트는 마지막 노드의 다음 노드가 null이 아니고 head 가리켜서 돌아오게 되는 순환되는 구조를 나타내는 자료구조입니다.
만약 이중 연결리스트가 원형 연결리스트의 특징을 가지게 된다면 이중 원형 연결리스트라고 합니다.

</details>

### 우선순위 큐에 대해서 설명해주세요

<details>

큐는 FIFO 구조로 먼저 나온 것이 먼저 나가는 방식입니다. 여기서 우선순위 수식어가 붙어서 먼저 나온 것이 나가는 것이 아니라 우선순위가 높은 데이터가 먼저 나가게 되는 자료구조입니다. 이것을 구현한 것으로 힙이 있습니다.

</details>

### 힙에 대해서 설명해주세요

<details>

우선순위 큐를 구현하기 위해 고안된 완전이진트리 형태의 자료구조입니다. 최댓값이나, 최솟값을 빠르게 찾아야 할 때 유용합니다.
종류로 최대 힙, 최소 힙이 있고 최대 힙은 부모 노드의 키 값이 자식 코드의 키 값보다 크거나 같은 완전이진트리, 최소 힙은 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전이진트리입니다.
요소를 삽입, 삭제 시에 재정비하는 시간은 O(logN)만큼 소요되고 모든 원소를 넣게 된다면 원소의 크기만큼 n번 곱해서 O(NlogN)의 시간 복잡도를 가지게 됩니다.

</details>

### 그래프에 대해서 설명해주세요

<details>

각 노드(Vertex)와 그 노드를 잇는 간선(Edge)으로 이루어져 있는 자료구조입니다.
방향, 무방향 그래프 그리고 사이클이 가능하다는 특징이 있습니다.

</details>

### 트리에 대해서 설명해주세요

<details>

그래프의 한 종류로서 노드와 그 노드를 잇는 간선으로 이루어져 있고 계층형 구조를 띠고 있는 비순환 그래프입니다.

</details>

### 트리 순회에 대해서 설명해주세요

<details>

트리 순회는 각 노드들을 체계적인 방법으로 방문하는 과정을 말합니다.
트리 순회 종류에는 전위(preorder), 중위(inorder), 후위 (postorder)순회가 있습니다.

전위 순회는 부모 노드 - 왼쪽 서브 트리 - 오른쪽 서브 트리 순으로 순회하는 방식을 말합니다.
중위 순회는 왼쪽 서브 트리 - 부모 노드 - 오른쪽 서브 트리 순으로 순회하는 방식을 말합니다.
후위 순회는 왼쪽 서브 트리 - 오른쪽 서브 트리 - 부모 노드 순으로 순회하는 방식을 말합니다.

</details>

### DFS와 BFS에 대해서 설명해주세요

<details>

DFS, BFS는 그래프를 탐색할 때 사용되는 알고리즘입니다.
DFS는 루트 노드에서 시작해서 서브 노드로 탐색을 시작하는데 이때 들어간 브랜치(분기)를 최대한 깊이까지 탐색을 한 뒤에 다음 브랜치로 이동해서 같은 탐색을 반복하는 알고리즘입니다.
BFS는 루트 노트에서 시작해서 인접한 모든 노드를 탐색한 뒤에 그다음 깊이인 노드에 들어가 또 인접한 모든 노드를 탐색하는 것을 반복하는 알고리즘입니다.

</details>

### 이진 트리에 대해서 설명해주세요

<details>

이진 트리는 각 노드의 자식 노드가 두 개로 구성되어 있는 트리입니다.
이진 트리 종류에는 편향 이진 트리, 포화 이진 트리, 완전 이진 트리가 있습니다.

편향 이진 트리는 모든 노드가 왼쪽이면 왼쪽 오른쪽이면 오른쪽으로 편향되어 있는 트리를 말합니다.
포화 이진 트리는 이진트리가 보유할 수 있는 최대 노드를 모두 가지고 있는 것을 말합니다. 이때 최대 노드는 2^(h - 1) - 1 입니다.
완전 이진 트리는 왼쪽에서 오른쪽 차례대로 쌓여있는 것을 말합니다.

</details>

### 이진 탐색 트리에 대해서 설명해주세요

<details>

이진 탐색 트리는 정렬된 이진 트리로서 각 노드는 두 개의 자식 노드를 가지고 왼쪽에 구성된 노드는 루트보다 작은 노드, 오른쪽에 구성된 노드는 루트보다 큰 값을 가지는 노드들의 집합으로 구조를 형성하는 트리입니다.
탐색할 때 검색하는 수가 계속해서 반으로 줄어들기 때문에 조회 시 시간복잡도는 O(logN)이고 만약 한쪽으로 편향되어 있는 이진 트리일 경우 최악의 경우 O(N)이라는 시간복잡도를 가집니다.

</details>

### 최소 신장 트리에 대해서 설명해주세요

<details>

트리의 속성을 가지기에 사이클이 존재하지 않고 모든 노드를 잇는 간선들의 가중치가 합이 최소가 되는 트리를 최소 신장 트리라고 한다.
최소 신장 트리를 구하는 알고리즘은 크루스칼, 프림 알고리즘이 존재합니다.

</details>

### 크루스칼 알고리즘에 대해서 설명해주세요

<details>

모든 간선을 가중치 기준으로 오름차순으로 정렬하여 작은 간선부터 두 노드를 연결하며 사이클이 존재하는지를 확인하며 사이클이 존재하면 다음 간선 아니라면 연결을 해서 모든 노드를 연결할 때까지 반복합니다.

</details>

### 프림 알고리즘에 대해서 설명해주세요

<details>

임의의 노드를 기준 노드로 잡고 시작하여 연결할 수 있는 간선 중에서 가장 작은 가중치를 가지는 간선을 이어 나가는 방식입니다. 가장 작은 간선을 찾기 위해서 우선순위 큐(힙)를 이용해서 간선을 가중치 기준으로 정렬합니다.

</details>

### Union-Find에 대해서 설명해주세요

<details>

서로 다른 두 노드가 같은 그래프에 속하는 그래프인지 판별하는 알고리즘입니다.

</details>

### 다익스트라 알고리즘에 대해서 설명해주세요

<details>

특정한 정점에서 다른 모든 정점까지 갈 수 있는 가중치가 최소가 되는 경로를 구하는 알고리즘입니다.

</details>

### 플로이드 워셜 알고리즘에 대해서 설명해주세요

<details>

모든 노드에서 다른 모든 노드까지 가는 최소 가중치를 구하는 알고리즘입니다.

</details>
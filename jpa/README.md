# JPA 예상 질문

### JDBC에 대해서 설명해주세요

<details>

자바에서 데이터베이스에 연결 및 작업하기 위한 자바 표준 인터페이스입니다. 데이터베이스 벤더와는 상관없이 하나의 jdbc api를 이용해 여러 데이터베이스에서 작업을 처리할 수 있습니다.

</details>

### ORM에 대해서 설명해주세요

<details>

객체와 RDBMS의 데이터를 매핑해주는 것을 말합니다.
OOP는 클래스를 사용하고 RDBMS는 테이블을 사용하는데 이 둘 간의 객체 모델과 관계형 모델 간의 패러다임 불일치를 해결해줍니다.

</details>

### JPA에 대해서 설명해주세요

<details>

JPA는 java의 orm 기술 표준으로 사용되는 인터페이스 모음입니다. 대표적인 구현체는 hibernate가 있습니다.

</details>

### JPA 장점에 대해서 설명해주세요

<details>

벤더의 독립성, 생산성, 유지보수, 패러다임 불일치 해결이 있습니다.
데이터베이스 벤더에 따라 처리하는 방법이 다를 수 있는데 추상화된 방법을 이용해서 벤더에 종속되지 않고 사용할 수 있게 되었습니다.
생산성은 반복적인 CRUD 작업을 대신해주고 update 같은 경우 dirty checking을 이용해서 변경되므로 생산성이 빨라지게 됩니다.
유지보수는 테이블 구조가 변경되었을 때 관련된 모든 sql문을 변경할 필요 없이 자동으로 변경이 이루어지므로 유지보수 또한 편해지게 됩니다.
ORM 기술인 JPA를 사용함으로써 상속, 연관관계, 동일성 보장 등 RDBMS와 객체의 패러다임 불일치를 해결할 수 있습니다.

</details>

### jdbc, sql mapper, orm 차이점에 대해서 설명해주세요

<details>

jdbc를 사용하면 jdbc driver만 따로 만들어준다면 db 벤더와 상관없이 연결이 가능하지만 간단한 sql을 실행하는데에도 중복된 코드를 반복해서 적어야 합니다.
sql mapper를 사용하면 jdbc에서 수행했던 반복 작업을 줄일 수 있다.
하지만 여전히 테이블마다 똑같은 단순 crud 작업을 반복해야 되고 개발자가 직접 sql문을 작성하기 때문에 발생할 수 있는 문제점, 테이블 구조 변경 시에 해당되는 모든 sql문도 찾아가 바꿔야 하므로 생산성이 많이 떨어집니다.
orm은 테이블마다 반복되는 crud 작업을 메소드로 지원하기 때문에 할 필요가 없고 sql문을 직접 작성하는 것이 아니기에 예기치 못한 실수도 피할 수 있습니다. 또한 테이블 구조가 변경되더라도 sql문을 직접 작성한 것이 아니기 때문에 일일이 찾아가서 변경해줄 필요가 없어져 생산성이 매우 높아지게 됩니다.

</details>

### JPA Global Fetch 전략에 대해서 설명해주세요

<details>

해당 엔티티를 조회할 때 연관된 엔티티를 함께 조회할 것인지 아닌지를 설정하는 것을 말합니다.
종류는 eager, lazy 두 가지가 있습니다. eager는 연관된 엔티티를 함께 조회하는 것을 말하고 lazy는 함께 조회하지 않고 연관된 엔티티를 프록시 객체로 담아놓고 실제 사용할 때 데이터베이스에 조회하는 것을 말합니다.
기본적으로 ManyToOne, OneToOne 은 eager 전략을 사용하고 ManyToMany, OneToMany는 lazy 전략을 사용합니다.

</details>

### JPA N+1 문제에 대해서 설명해주세요

<details>

엔티티를 조회할 때 연관 관계에 있는 엔티티의 개수만큼 N번 조회 그리고 해당 엔티티 조회 쿼리 한번 발생하여 한번 발생해야 될 쿼리가 N번 더 발생하여 성능 이슈를 일으키는 것을 말합니다.

</details>

### JPA N+1 해결하는 방법에 대해서 설명해주세요

<details>

해결하기 위해 총 세 가지 방법이 있습니다.
첫 번째로, GlobalFetch 전략을 EAGER에서 LAZY로 변경시키는 방법이 있습니다.
두 번째로, Fetch join을 이용해서 조회 시에 연관된 엔티티의 데이터들도 함께 조회해서 가져오는 방식이 있습니다.
세 번째로, EntityGraph라는 어노테이션을 이용하여 페치 조인을 하는 방법이 있습니다. 이 방식은 페치 조인과 차이점은 inner join이 아닌 left join으로 조인한다는 것입니다.

</details>

### 영속성 컨텍스트(persistence context)에 대해서 설명해주세요

<details>

엔티티들을 저장하고 관리하는 공간을 말합니다.

</details>

### 엔티티에 대해서 설명해주세요

<details>

데이터베이스 테이블과 1:1 매칭되는 클래스를 엔티티라고 합니다. 이 엔티티는 영속성 컨텍스트에서 관리되어 여러 이점을 얻을 수 있습니다.

</details>

### 엔티티 생명주기에 대해서 설명해주세요

<details>

엔티티의 상태는 준영속성, 영속성, 비영속성, 삭제가 있습니다.
비영속성은 영속성 컨텍스트에서 관리되지 않는 전혀 관계없는 객체를 말합니다.
영속성은 영속성 컨텍스트에서 관리되고 있는 객체를 말합니다.
준영속성은 영속성 컨텍스트에서 관리되다가 분리된 엔티티를 말하고 삭제는 영속성 컨텍스트와 데이터베이스에서 삭제된 객체를 말합니다.

</details>

### 영속성 컨텍스트를 쓰게 되면 이점에 대해서 설명해주세요

<details>

1차 캐시, 동일성 보장, 지연 로딩, 쓰기 지연, 변경 감지(dirty checking)이 있습니다.
1차 캐시는 영속성 컨텍스트에 엔티티들을 저장하고 해당 엔티티를 또 사용해야 될 때 데이터베이스까지 거치지 않고 바로 캐시에서 꺼내어 사용할 수 있게 해주는 것을 말합니다.
쓰기 지연은 매번 쿼리문을 발생시킬 때마다 커넥션 객체를 이용해서 db에 접근하는 것이 아니라 모든 쿼리문을 모아놨다가 트랜잭션이 끝날 시점에 한꺼번에 쿼리문을 보내는 것을 말합니다.
지연 로딩은 연관 관계가 있는 엔티티를 조회할 때 바로 가져오는 것이 아니라 필요로할 때 쿼리문을 발생 시켜 가져오는 것을 말하고 이를 통해 불필요한 데이터 참조를 줄일 수 있습니다.
변경 감지는 영속성 컨텍스트에서 관리되는 객체라면 사용자가 직접 쿼리문을 만들어주지 않아도 자동으로 변경된 엔티티를 감지하여 쿼리문으로 만들어 업데이트를 시켜주는 것을 말합니다.
동일성 보장은 영속성 컨텍스트에서 관리되고 있는 엔티티를 가져올 때 항상 같은 주소를 가질 수 있게 동일성을 보장하는 것을 말합니다.

</details>

### dirty checking에 대해서 설명해주세요

<details>

트랜잭션이 끝나는 시점에 영속성 컨텍스트에서 관리되는 엔티티 중에서 변화가 있는 엔티티를 찾아서 데이터베이스 자동으로 반영시켜주는 것을 말합니다.

</details>

### 기본키 매핑 방식에 대해서 설명해주세요

<details>

직접 할당하는 방식과 자동 생성 방식이 있습니다.
직접 할당하는 방식은 사용자가 @Id를 통해서 직접 주키를 설정하는 방식이고 자동 생성 방식은 @GeneratedValue를 이용해 기본키 생성 방식을 데이터베이스에 위임하는 방식입니다.
자동 생성 방식에는 IDENTITY, SEQUENCE, TABLE, AUTO로 나눠져있습니다.
identity는 키 생성 방법을 DB에 위임하는 방식입니다. 영속성 컨텍스트에서 엔티티를 관리하기 위해서는 식별자로 id가 필요한데 이 방식을 이용하면 insert 쿼리를 날리기 전에는 id 값을 알 수 없기 때문에 commit 시점이 아닌 persist 시점에 insert query를 발생 시켜 식별자를 조회해 가져오는 특징이 있습니다.
sequence는 db sequence object를 사용하는 방식입니다. db의 sequence를 통해 식별 id를 가져오기에 insert query를 바로바로 보낼 필요 없고 모아서 보낼 수 있다. 이때 db sequence를 통해 id를 가져오기 위해 네트워크를 타는데 성능 저하가 있을 수 있기에 할당 사이즈를 주어 한꺼번에 여러 개의 식별 id를 가져와 설정할 수 있습니다.
table은 키 생성 전용 테이블을 따로 만들어서 키를 관리하는 방식입니다.
auto는 벤더에 따라 자동으로 설정되는 방식입니다.

</details>

### 낙관적, 비관적 잠금에 대해서 설명해주세요

<details>

낙관적 잠금은 동시에 데이터 갱신이 일어나지 않을 것이라고 보는 것을 말합니다. 예를 들어 회원정보 변경이 있습니다.
비관적 잠금은 동시에 데이터 갱신이 발생할 것이라 보고 잠금을 거는 것을 말합니다. 예로 계좌이체나 재고 변경이 있습니다.

</details>

### OSIV에 대해서 설명해주세요

<details>

말 그대로 영속성 컨텍스트를 뷰까지 열어두겠다는 의미입니다.
osiv가 true라면 커넥션 시작부터 api 응답이 끝날 때까지 영속성 컨텍스트를 유지하게 됩니다. 영속성 컨텍스트를 계속 열어둔다는 것은 컨트롤러 단에서도 지연로딩이 가능하다는 이점을 얻을 수 있고 DB 커넥션을 오랫동안 사용한다는 것이므로 실시간 트래픽이 많이 발생하게 되면 커넥션이 부족한 상황이 올 수 있습니다. 또한, 뷰에서 보여줘야 할 데이터를 기본값에서 가공해야 될 때 영속성 컨텍스트가 연결되어있어서 변경 감지로 인해 문제가 생길 수도 있습니다.
osiv가 false라면 트랜잭션이 종료될 때 영속성 컨텍스트를 닫고 DB커넥션도 반환하기 때문에 커넥션 리소스를 낭비하지 않습니다. 또한 변경 감지가 일어나지 않기 때문에 실수로 데이터를 가공해서 DB에 반영되는 일은 발생하지 않습니다. 하지만 지연 로딩은 발생하지 않기에 트랜잭션 내에서만 처리해야 합니다.

</details>

### JPA Propagation에 대해서 설명해주세요

<details>

트랜잭션 어노테이션이 달린 메소드가 중첩되었을 때 어떻게 동작할지 결정하는 것입니다.
default 값으로 required가 설정되어있고 이미 시작된 트랜잭션이 있으면 그 트랜잭션에 참여하고 아니면 새로운 트랜잭션으로 시작하게 됩니다.
requires_new는 항상 새로운 트랜잭션으로 시작을 하고 이미 진행 중인 트랜잭션이 있다면 현재 트랜잭션을 보류시킵니다.
supports는 이미 시작된 트랜잭션이 있으면 참여하고 없다면 트랜잭션 없이 진행합니다.
nested는 중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만, 자신의 커밋과 롤백에는 부모 트랜잭션에 영향을 주지 않습니다.
이 외에도 mandatory, not_supported, never가 있습니다.

</details>
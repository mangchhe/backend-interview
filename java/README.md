# Java 예상 질문

### String, StringBuilder, StringBuffer 차이점은 무엇인가요?

<details>

String과 그 외 StringBuffer, StringBuilder는 Immutable한 속성을 가지고 있냐 없냐에 대해서 차이점을 가지고 있습니다.
String은 값을 변경하기 위해서는 기존 주소에서 값만 변경되는 것이 아닌 새로운 주소 값이 할당되게 되고 StringBuffer나 StringBuilde는 내부적으로 값을 변경하는 메소드를 이용해서 기존 주소에서도 값을 변경할 수 있습니다.
StringBuilder와 StrinBuffer의 차이점은 동기화 유무입니다. StringBuilder는 동기화를 지원하지 않는 반면 StringBuffer는 동기화를 지원합니다.
그렇기에 StringBuffer는 멀티스레드 환경에서 안전하며 StringBuilfer는 그렇지 않습니다. 하지만 StringBuffer는 동기화로 인한 락을 걸고 해제하는 연산으로 인해 오버헤드가 발생하기에 Builder보다 성능을 떨어질 수 있습니다.
String 또한 Immutable한 속성을 가지고 있기 때문에 멀티스레드 환경에서 안전하다고 볼 수 있습니다.

</details>

### 객체지향프로그래밍이 뭔가요?

<details>

객체지향프로그래밍은 현실세계에 있는 사람이나/물체들을 추상화하여 객체로 만들어, 만들어진 객체들의 유기적인 상호작용으로 프로그램을 만들어가는 프로그래밍 방법입니다.

</details>

### 객체지향프로그래밍 특징에는 무엇이 있나요?

<details>

객체지향프로그래밍에는 상속, 추상화, 다형성, 캡슐화의 총 네 가지 특징이 있습니다.
상속은 이전에 만들어놓은 속성이나 행위들을 또 구현하지 않고 상속받아서 똑같은 기능을 또 구현할 필요 없이 사용을 하는 것을 말합니다.
추상화는 다양한 형태를 가질 수 있는 형체의 공통적인 부분을 떼어내 하나로 묶어서 정의하는 것을 말합니다.
다형성은 추상화가 되어 있는 형체를 그때 그때 상황에 맞는 형태로 만들어내서 사용하는 것을 말합니다.
캡슐화는 서로 관련이 있는 상태와 행위를 하나의 클래스에 묶어서 관리하고 은폐하는 것을 말합니다.

</details>

### 객체지향프로그래밍 장점은 무엇이 있나요?

<details>

첫 번째로 코드 재사용성이 좋습니다. 상속과 같은 특징으로 인해서 불필요한 코드 작성을 줄일 수 있기 때문입니다.
두 번째로 유지 보수가 좋습니다. 각각의 클래스는 캡슐화가 되어 있기 때문에 각 클래스의 주변에 미치는 영향을 최소화할 수 있고 즉, 관련된 로직은 외부에서 찾을 필요 없이 해당 클래스에서 확인할 수 있으며 느슨한 결합을 얻어낼 수 있습니다. 그리고 추상화나 다형성으로 인해서 좀 더 명확하고 가독성 있는 표현이 가능합니다.
세 번째로 모델링 하기가 쉽습니다. 현실 세계에 있는 사물이나 사람을 대상으로 상태와 행위를 뽑아내서 객체를 프로그래밍을 구성하기 때문에 이해하기 쉽습니다. 예를 들어 사람을 만든다고 가정한다면 눈, 코, 입, 팔, 다리는 상태 팔을 휘젓다, 걷다 등이 행위가 되기에 보기에도 명확하고 접근하기 쉽다.

</details>

### 객체지향프로그래밍 단점은 무엇이 있나요?

<details>

첫 번째로 설계하는 단계에서 비용이 많이 든다. 프로그래밍을 하기 위해서는 클래스를 만들고 클래스 간의 관계도 생각해야 되기 때문에 설계하는 데 있어서 시간이 많이 든다.
두 번째로 절차지향 같은 프로그래밍 기법에 비해 시간이 오래 걸립니다. 이유는 모든 것은 클래스로 이루어져 있고 캡슐화라는 특징으로 인해 모든 것은 메소드를 통해 전달이 되기도 하기 때문에 좀 더 명령어를 해석하는 데에 있어서 더 큰 시간을 소요하기 때문입니다.

</details>

### 객체지향과 절차지향의 차이점은 무엇인가요? 🤔

<details>

절차지향은 순차적인 처리를 중요시하며 프로그램 전체가 유기적으로 연결되어 프로그래밍하는 기법을 말합니다. 예를 들어 공장과 같은 프로세스와 같다고 생각합니다.
객체지향은 현실 세계를 모델링하여 각각의 부품들을 조립하듯이 프로그램을 만들어나가는 프로그래밍 기법입니다.

</details>

### 기본형 변수와 참조형 변수는 무엇이 있나요?

<details>

기본형 변수는 총 8가지로 boolean, byte, short, char, int, long, float, double이 존재합니다.
참조형 변수는 기본형 변수를 제외한 타입들 배열이나, 객체와 같은 변수들을 말합니다.

</details>

### 메모리 누수는 무엇인가요?

<details>

프로그램에서 사용하다가 현재 사용하고 있지 않은 메모리를 점유하고 있는 것을 말합니다. 즉 자바에서는 더이상 사용되고 있지 않는 객체들을 가비지컬렉션이 회수해가지 않는 것을 말합니다.
회수해가지 않게 된다면 old 영역이 계속 쌓이게 되고 major gc가 빈번히 일어나 프로그램 응답속도가 느려지고 결국 OutofMemory를 발생시키며 비정상 종료가 되게 됩니다.

</details>

### 자바에서 메모리 누수의 예는 어떤 게 있나요?

<details>

map이나 set 자료형이 커스텀 객체를 담을 때 equals, hashcode를 재정의하지 않는다면 계속해서 같은 값이 쌓이는 현상이면서 메모리 누수가 발생합니다.
그리고 int를 사용해도 되는 게 굳이 Integer와 같은 래퍼 클래스를 생성해서 사용하는 경우들이 있습니다.

</details>

### Static 키워드에 대해서 설명해주세요

<details>

애플리케이션을 실행할 때 한 번만 메모리를 할당하여 값을 저장하는 것을 말하고 같은 메모리 공간을 가지고 있기 때문에 공유할 때 사용됩니다.
공유할 때 사용하기 때문에 웬만하면 immutable한 변수로 사용하는 것이 좋고 그렇지 않다면 동기화 문제를 해결해서 사용해야 합니다.

</details>

### 익명 클래스가 무엇인가요?

<details>

말 그대로 클래스에 이름이 없는 것을 익명 클래스라고 합니다. 익명 클래스는 어떤 인터페이스를 사용할 때 자주 사용되지 않는 일회용으로 사용한다면 재사용할 필요가 없기 때문에 필요로 할 때 익명 클래스로 구현해서 사용합니다.

</details>

### 자바 문자열 검색 메소드 종류가 어떤 게 있나요?

<details>

해당 문자열의 인덱스를 구하고 싶을 땐 indexOf, 문자열을 포함하고 있는지 알기 위해서는 contains 그리고 정규식으로 문자열을 검색하기 위해서는 matches를 이용합니다.

</details>

### 접근자는 무엇이고 종류가 어떤 게 있나요?

<details>

접근자는 클래스나 멤버 변수, 메소드에 어디까지 접근을 허용할 것인지 허용 범위를 결정하기 위해서 사용합니다.
종류는 허용 범위가 넓은 순으로 public, protected, default, private이 있습니다.
public은 접근 제한이 없는 것을 말하고 protected는 같은 패키지 내에 있거나 다른 패키지에 자식 클래스까지 허용하며 default는 같은 패키지 내에서만 private은 클래스 내에서만 접근을 허용합니다.

</details>

### 클래스, 추상클래스, 인터페이스 차이점이 무엇인가요?

<details>

클래스는 완성된 설계도라고 한다면 추상클래스와 인터페이스는 미완성 된 설계도입니다.
클래스는 인스턴스로 생성이 가능하고 추상 클래스와 인터페이스를 인스턴스로 생성이 불가능합니다.
클래스와 추상클래스는 단일 상속만 가능하지만 인터페이스는 다중 상속이 가능합니다.
클래스는 멤버 변수와 기본 메소드로만 이루어져 있고 추상 클래스는 추상 메소드, 그리고 공통 기능을 하는 기본 메소드로 이루어져 있습니다.
인터페이스와 같은 경우는 자바8 이전에는 추상 메소드로만 이루어져 있었지만 java8에서는 함수를 구현할 수 있는 default method 그리고 java9는 private, static 메소드도 추가할 수 있게 변경되었습니다.

</details>

### 컬렉션 프레임워크가 무엇인가요?

<details>

다수의 데이터를 효율적으로 다루기 위한 표준화된 방법을 제공하는 클래스들의 집합입니다. 즉, 자료구조들의 집합입니다.

</details>

### 컬렉션 프레임워크 핵심 인터페이스에 대해 설명해주세요 🤔

<details>

List, Set, Queue 인터페이스가 있습니다.
List는 연속적인 메모리 공간을 가진다는 데이터들의 집합이고 중복이 가능합니다. 반면 Set은 불규칙한 메모리 공간을 가지고 있으면 중복이 불가능합니다.

</details>

### SOLID 원칙이 무엇인가요?

<details>

객체지향적으로 프로그래밍하기 위해서 지켜야 할 5가지 원칙을 말합니다.
약자 순서대로 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전의 원칙이 있습니다.
단일 책임 원칙은 각 클래스는 하나의 책임만을 가지고 있어야 한다는 말입니다. 즉 한 가지 일을 해야만하지 이것저것 다른 일도 겸해서 해서는 안 된다는 말입니다.
개방 폐쇄 원칙은 기존 소스 코드는 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 한다는 것입니다. 보통 자주 사용되는 문법은 인터페이스입니다.
리스코프 치환 원칙은 자식 클래스는 부모 클래스가 할 수 있는 행위를 수행할 수 있어야 한다는 것입니다. 예로 도형이라는 클래스가 있을 때 둘레가 있고 넓이를 가지고 있고 각을 가지고 있다고 했을 때 사각형을 구현한다면 이 세 가지가 모두 충족되지만 원이라는 도형을 넣게 되면 도형이기는 하지만 원은 각을 가지고 있기 때문에 원칙을 위배한다고 할 수 있습니다.
인터페이스 분리 원칙입니다. 인터페이스를 구현하는 클래스가 있을 때 해당 클래스가 사용하지 않는 기능을 가지고 있는 인터페이스를 구현하는 것보다 이러한 인터페이스를 분리를 해서 구현이 필요한 내용만 구현을 할 수 있도록 하는 것을 말합니다.
의존 역전의 원칙은 변화하기 쉬운 것을 의존하는 것이 아니라 변하기 어려운 것을 의존하라는 말입니다. 즉 구현 클래스는 변경 가능성이 크기 때문에 구현 클래스보다는 추상 클래스나 인터페이스와 관계를 맺는 것이 더 유연한 구조를 만들 수 있다는 것입니다.

</details>

### 배열과 컬렉션의 차이점이 무엇인가요?

<details>

이 둘의 차이점은 데이터를 저장하는 공간이 정적이냐 동적이냐의 차이점입니다. 배열은 초기에 공간을 정확히 초기화시켜줘야 하는 반면 컬렉션은 그때그때 값을 추가하거나 삭제할 때 공간이 가변적으로 줄어들었다 늘어났다 합니다. 그다음으로 담을 수 있는 타입 배열은 같아야 하지만 컬렉션은 여러 가지의 타입을 담을 수 있습니다.

</details>

### JVM의 메모리 영역(Runtime Data Area)에 대해서 설명해주세요

<details>

JVM 메모리 영역에는 메소드, 스택, 힙, PC Register, Native Method Stack 영역으로 구성되어 있습니다.
메소드 영역은 메소드나 멤버 변수, 접근 제어자와 같은 클래스 정보들을 담는 공간입니다.
스택 영역은 함수와 호출과 동시에 생기는 영역으로 지역 변수나 파라미터 정보들을 담는 공간입니다.
힙 영역은 사용자가 동적으로 생성한 객체들이나 배열을 저장하는 공간입니다.
PC Register는 Thread가 생성될 때마다 생성이 되는 공간으로 현재 스레드의 실행되는 부분의 주소와 명령을 저장하는 공간입니다.
Native Method Stack은 자바 외의 언어들로 작성된 코드를 저장하는 공간입니다.
이때 Method, Heap 영역은 모든 스레드가 공유하는 반면 Stack, PC Register, Native Method Stack은 영역은 스레드 마다 생성이 되면 공유하지 않습니다.

</details>

### JVM Heap 영역에 대해서 자세히 설명해주세요

<details>

힙 영역은 사용자가 동적으로 생성한 객체들이나 배열을 저장하는 공간이고 GC에 의해 관리되는 공간입니다.
영역은 Eden, Survivor1, 2로 young 영역과 old, permanent로 old 영역으로 나눠져 있습니다. 이 영역들은 Eden 영역부터 차례대로 메모리 공간을 차지하게 되며 가득 찼을 경우 gc가 발생하게 되고 사용되지 않는 영역은 반환하고 사용하는 영역들은 그다음 survivor1으로 넘어가게 됩니다. 이러한 행위가 반복이되고 survivor1도 가득차게 되면 survivor2로 이동되는 형태로 진행되게 됩니다. 앞에 있는 영역일수록 공간이 적고 gc가 자주 발생하게 됩니다. 자주 발생하게 설계한 이유는 생성된 지 얼마 안 된 객체일수록 더 빨리 사용되지 않을 가능성이 높다는 결과가 있기 때문입니다.

</details>

### Young, Old 영역으로 나눈 이유가 어떤 거라고 생각하시나요?

<details>

gc를 하게 되면 stop the world라고 애플리케이션의 스레드를 잠깐 모두 중단시키기 때문에 자주 하거나 모든 객체들을 검사하기는 부담이 될 수밖에 없습니다.
그렇기 때문에 좀 더 효율적으로 gc를 하기 위함입니다.

</details>

### Comparable 과 Comparator의 공통점, 차이점은 무엇인가요

<details>

공통점은 둘 다 인터페이스이며 객체의 정렬 조건을 설정할 때 사용되게 됩니다.
차이점은 Comparable은 클래스 레벨로 클래스의 기본 정렬 조건을 결정하게 되며 런타임 시에 정렬 조건을 변경할 수 없습니다. 반면 Comparator은 익명 클래스로 구현하여 그때그때 객체 정렬 조건을 런타임 시점에 변경할 수 있습니다.

</details>

### 제네릭이 무엇인지 설명해주세요

<details>

제네릭은 컴파일 시점에 타입을 결정하는데 사용되는 것을 말합니다. 예로 컬렉션 클래스 자료형을 결정할 때 사용됩니다.
제네릭을 사용하게 되면 강력한 타입 체크가 가능하기 때문에 내가 짠 비즈니스 로직에 의도치 않은 타입이 들어오는 상황을 사전에 방지할 수 있습니다.
그리고 불필요한 캐스팅이 발생하지 않습니다. 만약 제네릭을 하지 않았다면 Object로 저장이 되기 때문에 꺼내어서 원하는 처리를 하기 위해서는 타입 변환을 해야 하기 때문에 오버헤드가 발생하게 됩니다.

</details>

### 상수풀이 무엇인지 설명해주세요

<details>

JVM 메모리 영역 중에 Method나 Heap 영역에 존재하는 공간입니다. 이 공간은 String이나 Integer와 같은 타입들의 리터럴 값을 저장하고 가져오기 위해서 사용됩니다. 이렇게 재사용하는 이유는 String, Integer와 같은 타입은 자주 사용되는 타입으로 그때마다 Heap 영역에 저장하게 되면 메모리 낭비가 심해지기 때문에 이를 방지하기 위해서 상수풀을 이용해 메모리를 절약합니다.

</details>

### Boxing & UnBoxing이 무엇인가요?

<details>

박싱은 int, bool 같은 primitive type을 Wrapper 클래스인 Integer와 Boolean으로 만드는 과정을 말하고 언박싱은 그 반대로 Wrapper 클래스를 기본형 타입으로 변경하는 것을 말합니다.

</details>

### 굳이 나눠서 쓰는 이유가 있나요?

<details>

Wrapper 클래스를 쓰게 되면 내부적으로 지원하는 함수들을 사용할 수 있고 제네릭을 쓰기 위해서는 기본형이 아닌 래퍼 클래스만을 지원하기 때문입니다. 그리고 DAO와 같은 객체를 사용할 때 Null을 허용해야 하는 상황이 존재할 수 있기 때문에 래퍼 클래스를 사용합니다.
그 외 연산만을 해야 하는 상황이라면 기본형 타입으로 사용하는 것이 좋습니다.

</details>

### Optional가 무엇인가요?

<details>

개발 도중에 만나는 NullPointException에 유연하게 대처하기 위해서 Null을 다루기 위한 방법들을 제공하는 것이 Optional입니다.

</details>

### Java8 변경사항은 무엇이 있나요?

<details>

람다 표현식, Stream API, java.time, Optional, 함수형 인터페이스가 도입되었습니다.
람다 표현식은 익명 클래스의 한 개의 메소드를 표현한 것이고 이러한 람다를 이용해서 함수형 프로그래밍이 가능하게 되었습니다.
Stream API를 이용해서 서로 다른 자료구조들을 추상화하여 동일 방식으로 다룰 수 있게 되었고 java.time 라이브러리를 통해서 좀 더 다양한 메소드와 달이 0부터 시작한다던가 윤년을 고려하지 않거나 mutable한 속성을 가진다는 문제점을 해소하였습니다.
옵셔널을 이용해서 null을 안전하게 다룰 수 있도록 지원합니다.
함수형 인터페이스는 하나의 기능을 제공하는 하나의 추상 메소드만을 정의하는 인터페이스입니다.

</details>

### java11의 변경사항은 무엇이 있나요?

<details>

String 클래스, 컬렉션 인터페이스, Predicate 인터페이스에 새로운 메소드가 추가되었고, 람다에서 로컬 변수 var가 사용이 가능해졌고 자바 파일 실행 시 javac를 통해 컴파일을 하지 않고도 자바를 실행할 수 있게 되었습니다.
String 클래스에는 trim과 같은 strip과 stripLeading, stripTailing, isBlank, repeat 함수가 추가되었습니다.
컬렉션 인터페이스에는 toArray와 같이 원하는 타입으로 변경할 수 있는 메소드가 추가되었습니다.
predicate 인터페이스에는 not()이라는 부정을 나타내는 메소드가 추가되었습니다.

</details>

### GC(Garbage Collection)은 무엇인가요?

<details>

애플리케이션을 구동하면서 사용하지 않는 메모리 영역을 해제하는 역할을 하는 것이 GC입니다.

</details>

### GC의 동작 방식은 어떻게 되나요?

<details>

Stop the World를 하게 되는데 JVM이 GC 스레드를 제외 나머지 애플리케이션 스레드를 잠깐 정지시키게 됩니다.
그리고 Mark And Sweep을 하여 현재 참조하고 있는 사용되고 있는 객체들을 mark하고 이러한 mark 된 객체를 sweep 단계에서 마크가 안 된 unreachable 객체들을 모두 제거하는 방식으로 진행이 됩니다.

</details>

### 리플렉션(Reflection)이 무엇인가요?

<details>

구체적인 클래스 타입을 알지 못해도 그 클래스의 타입이나 메소드 변수들에 접근할 수 있도록 해주는 자바 API입니다.
이때 구체적인 클래스 타입을 알지 못한다는 것은 모든 클래스의 조상 클래스인 Object에 어떤 클래스든 담을 수는 있지만 어떤 클래스인지 구체적으로 알지 못한다면 즉 캐스팅을 하지 않는다면 사용 가능한 메소드는 조상 클래스의 Object 것만 사용이 가능하다.

</details>

### 직렬화란 무엇인가요?

<details>

자바에서 사용하는 객체와 같은 데이터를 외부에서 사용할 수 있도록 바이트 형태로 데이트를 변환하는 것을 말한다. 보통 파일로 보내거나 네트워크 통신을 할 때 직렬화 과정이 발생한다.

</details>

### Map에 대해서 설명해주세요

<details>

Map은 Key와 Value 쌍으로 이루어져 데이터를 담을 수 있는 자료구조입니다. 종류로는 hashMap, hashTable, linkedHashMap, TreeMap이 있습니다.

</details>

### HashMap과 HashTable의 차이점이 무엇인가요?

<details>

차이점은 동기화 유무와 key, value 값에 null 값을 허용하는지, 추가적인 보조 해시 함수를 지원하는지에 대한 차이점이 존재합니다.
HashMap은 key, value는 null 값을 허용하고 HashTable은 null 값을 허용하지 않습니다.
HashMap은 동기화를 지원하지 않고 HashTable은 동기화를 지원합니다.
HashMap은 추가적인 보조 해시 함수를 지원하기에 해시 충돌이 덜 일어나는 성능상 이점이 있지만 HashTable은 보조 해시 함수를 지원하지 않습니다.

</details>

### HashMap은 null을 지원하고 HashTable은 지원하지 않는 이유가 뭐라고 생각하나요? 🤔

<details>

값이 null로 들어오면 처리 방식이 좀 더 복잡해지기 때문에 초창기에 나온 HashTable은 지원하지 않고 후에 나온 HashMap은 지원한다고 생각합니다.

</details>

### HashMap은 동기화를 할 수 없는 건가요?

<details>

Java5에 나온 CurrentHashMap을 이용하여 동기화를 할 수 있습니다. 또는 Collections에 있는 synchronizedMap과 같은 메소드를 이용해 동기화된 컬렉션을 만들어낼 수 있습니다.

</details>

### HashSet에 대해서 설명해주세요

<details>

HashSet은 순서를 보장하지 않고 중복 데이터를 허용하지 않는 자료구조입니다. 중복 데이터를 허용하지 않기 때문에 HashCode, equals를 이용해서 중복을 검사하기 때문에 만약 커스텀 객체를 이용한다면 필시 재정의를 해주어야 합니다.
순서를 보장하기 위해서는 LinkedHashSet를 사용하면 되고 TreeSet을 이용하여 값을 기준으로 정렬된 상태로 만들 수도 있습니다.

</details>

### Hash Collision 해결 방법은 어떻게 되나요?

<details>

해시 충돌을 해결하는 방법에는 체이닝 방식과 개방 주소법 두 가지가 있습니다.
체이닝 방식을 이용하면 버킷 공간에 linkedList를 넣어서 충돌이 일어났을 때 계속 이어서 넣게 됩니다.
개방 주소법은 충돌이 일어나면 다른 버킷에 넣는 방법을 말하고 선형 탐색, 제곱 탐색, 이중 해시 방법이 있습니다.
선형 탐색은 현재 버킷의 몇 개의 공간을 건너뛰어 넣는 것을 말하고 제곱 탐색은 현재 버킷을 제곱하는 방식으로 띄어서 넣는 방식과 이중 해시는 나온 값을 한 번 더 해시 함수에 넣어서 나온 주소에 넣는 것을 말합니다.
체이닝 방법은 간단하지만, 추가적인 메모리 공간이 필요로 하고 골고루 분포되어있지 않다면 선형 탐색과 다를 바 없는 상태가 되게 됩니다.
개방 주소법은 추가적인 메모리 공간이 필요 없고 적은 데이터를 넣을 때 유리합니다. 데이터를 많이 넣는다면 해시 충돌이 일어날 가능성이 더 커지기 때문입니다.

</details>

### ArrayList는 왜 연속적으로 데이터를 할당한다고 생각하나요?

<details>

캐시 메모리에 공간 지역성을 이용하기 위함이라고 생각합니다. ArrayList와 같은 연속적인 배열을 사용할 때 선형 탐색을 조회하는 경우가 많기 때문에 메모리가 여기저기 분산되어 있는 것보다 연속적으로 있는 것이 캐시를 이용해 성능 이점을 얻을 수 있습니다.

</details>

### ArrayList와 LinkedList의 공통점은 무엇인가요?

<details>

동적으로 데이터를 추가 및 삭제를 할 수 있다는 공통점이 있습니다.

</details>

### ArrayList와 LinkedList의 차이점은 무엇인가요?

<details>

ArrayList는 연속적인 메모리 공간을 가지는 배열이고 LinkedList는 불 규칙적인 메모리 공간을 가지는 배열입니다. 그래서 LinkedList는 각각의 노드가 다음 노드를 가르키는 주소를 담고 있어야 하기 때문에 추가적인 메모리 공간이 필요하게 됩니다.
대신 ArrayList는 값을 중간에 추가하거나 삭제하게 되면 메모리 공간을 연속적으로 유지해야 하기 때문에 O(N)이 걸리는 반면 LinkedList는 추가 삭제 시에 앞에 있는 주소만 빼려고 하는 다음 주소로 연결하면 되기 때문에 O(1)이 걸리게 됩니다.

</details>

### hashCode와 equals를 재정의해야 하는 이유는?

<details>

hashCode와 equals는 기본적으로 동일성이 비교이기 때문에 이 두 함수를 사용해야 하는 hashSet이나 hashMap과 같은 클래스를 이용하려고 할 때 문제가 생긴다.
hashCode에 input 값을 넣어 나오는 output으로 인덱싱을 하여 값을 저장하게 되는데 동일성 비교이게 되면 같은 값을 가지는 데이터가 들어와도 서로 다른 값으로 판단을 하기 때문에 동등성 비교로 변경을 해주어야 한다.
equals 또한 값을 비교하거나 contains와 같은 메소드 함수를 사용하려고 한다면 내부 로직을 보면 equals를 사용하기 때문에 정확한 비교를 하기 위해서는 동등성으로 변경을 해주어야 올바른 값을 도출해낼 수 있다.

</details>

### 어노테이션에 대해서 설명해주세요

<details>

인터페이스 기반으로 한 문법으로 주석처럼 코드에 달아 클래스나 메소드에 특별한 의미를 부여하거나 기능을 주입할 때 사용합니다.

</details>
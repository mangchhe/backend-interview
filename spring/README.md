# Spring 예상 질문

### POJO에 대해서 설명해주세요

<details>

어떤 기술이나 환경에 종속되지 않고 필요에 따라 언제든지 재활용이 가능한 순수 자바 객체를 말합니다.

</details>

### Spring에 대해서 설명해주세요

<details>

엔터프라이즈급 애플리케이션을 보다 쉽게 만들기 위한 환경을 제공해주는 프레임워크입니다.

</details>

### Spring 같은 프레임워크를 사용하는 이유가 무엇인가요?

<details>

Spring 프레임워크를 사용하게 되면 여러 가지 기술들을 받음으로써 개발자들이 효율적으로 서비스 개발에 집중할 수 있고 추후 유지보수 측면에서도 좋은 결과를 얻을 수 있기 때문에 사용한다고 생각합니다.

</details>

### Spring Boot는 Spring과 어떤 게 다른 건가요?

<details>

Spring Boot는 Spring을 사용했을 때 버전 간의 의존성 설정해야 했던 것을 자동화해서 도와주게 됩니다.
spring을 사용하게 되면 라이브러리나 프레임워크를 추가하려고 할 때 각각의 버전들을 고려해서 사용자가 직접 맞춰줘야 하지만 spring boot를 사용하면 자동으로 맞춰주기 때문에 많은 시간을 절약 또는 실수를 방지할 수 있습니다.

</details>

### Spring Bean에 대해서 설명해주세요

<details>

스프링 IoC 컨테이너에 의해서 관리되고 애플리케이션 핵심을 이루는 객체들을 spring bean이라고 합니다.

</details>

### Spring Bean의 life cycle에 대해서 설명해주세요

<details>

객체 생성 이후에 의존설정, 주입, 초기화, 소멸이라는 단계를 거칩니다. 이러한 빈들은 스프링 컨테이너 생성과 동시에 생기게 되고 컨테이너가 종료되면 빈들도 함께 소멸하게 됩니다.

</details>

### IoC에 대해서 설명해주세요

<details>

객체의 생성과 소멸까지의 생명주기를 사용자가 직접 관리하는 주체였다면 이제는 사용자가 아닌 스프링 프레임워크가 그것을 대신해서 관리한다는 것입니다.

</details>

### Bean Scope에 대해서 설명해주세요

<details>

빈 스코프는 빈이 존재할 수 있는 범위를 말하며, 디폴트인 싱글톤, 프로토타입, request, session, appllication 등이 있습니다.
싱글톤은 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프를 말합니다.
프로토타입은 빈의 생성과 의존관계 주입까지만 관여하는 매우 짧은 범위의 스코프를 말합니다.
request는 웹 요청이 들어오고 나갈 때까지 유지하는 스코프, 세션은 웹 세션이 생성되고 종료할 때까지, application은 웹 서블릿 컨테이너와 같은 범위로 유지하는 스코프입니다.

</details>

### 싱글톤과 프로토타입 빈을 섞어서 사용했을 때 문제점에 대해서 설명해주세요

<details>

프로토타입 빈이 싱글톤 빈을 참조하는 경우에는 문제가 생기지 않는다.
하지만 싱글톤 빈에서 프로토타입 빈을 참조하는 경우에는 싱글톤 빈은 단 한 번만 생성하기에 문제가 생긴다.
프로토타입 빈은 계속 업데이트가 되는데 이미 다른 이전 업데이트되지 않은 프로토타입 빈을 참조하는 싱글톤 빈은 사용자의 의도와는 다르게 동작할 수 있기 때문에 문제가 생길 수 있다.

</details>

### 싱글톤과 프로토타입 빈을 섞어 발생하는 문제점은 어떻게 해결할 수 있나요?

<details>

첫 번째로 proxyMode를 설정하여 프로토타입에 프록시로 감싸서 문제를 해결합니다.
싱글톤 빈은 프로토타입을 직접 참조하는 것이 아니라 프로토타입을 감싸고 있는 프록시를 참조하기 때문에 이 문제를 해결할 수 있다.
두 번째는 ObjectProvider로 감싸는 것입니다.
이를 이용하면 지정한 빈을 컨테이너에서 찾아주는 DL 서비스를 받을 수 있습니다.

</details>

### 스프링 Bean을 등록하는 방법에 대해서 알려주세요

<details>

등록하는 방법은 컴포넌트 스캔 방식과 설정 파일을 이용해 직접 빈으로 등록시키는 방식이 있습니다.
클래스에 컴포턴트 어노테이션을 붙이게 되면 애플리케이션 실행 시에 클래스를 모두 돌면서 컴포넌트가 달린 클래스를 빈으로 등록하게 됩니다.
또는 Configuration 어노테이션을 달아 설정 클래스를 만들고 안에 메소드 레벨로 빈을 작성하게 되면 빈으로 등록할 수 있습니다.

### @Bean과 @Component로 등록했을 때의 차이점에 대해서 설명해주세요

component로 빈으로 등록시킬 경우 클래스 레벨에서 사용이 가능하며 사용자가 직접 구현하고 컨트롤 가능한 클래스에 사용한다.
빈은 메서드 레벨에서 사용 가능하며 직접 만든 클래스를 빈 방식으로 등록시킬 수도 있고 그 외에 사용자가 구현을 바꿀 수 없는 컨트롤할 수 없는 외부 라이브러리들은 빈 방식으로 등록시킬 수도 있습니다.

</details>

### 의존성 주입하는 방법에 대해서 알려주세요

<details>

의존성 주입을 하기 위해서는 필드, setter, 생성자를 통한 주입 세 가지 방식이 있습니다.

</details>

### 어떤 의존성 주입을 하는 것이 좋나요?

<details>

스프링 레퍼런스를 보면 생성자 주입을 권장하고 있습니다.
이유는 첫 번째로 순환 참조를 방지할 수 있습니다. A가 B를 필요로 하고 B가 C, C가 A를 참조할 때 순환 참조가 발생하게 되는데 세터나 필드는 인스턴스 생성 이후에 초기화하기 때문에 실제 코드를 사용하기 전까지는 알 수 없고 생성자를 이용하면 생성될 때 초기화되어야 하기 때문에 컴파일 시점에 알 수 있습니다.
두 번째로 field에 final 옵션을 주어 불변성을 보장할 수 있습니다. 필드나 세터는 앞에서와 동일하게 인스턴스 생성 이후에 초기화를 할 수 있기 때문에 final이 불가능하지만, 생성자는 생성과 동시에 초기화해야 하므로 final이 가능하며 불변성을 보장한다.
세 번째로 필드 주입은 DI 프레임워크 없이는 의존성 주입이 동작하지 않기 때문에 테스트를 할 때 단위 테스트가 불가능합니다. 필드 주입을 테스트하기 위해서는 스프링 빈을 생성해야 되고 그럼 테스트를 할 때마다 비용이 늘어날 수밖에 없고 무거워집니다.
NPE를 방지할 수 있습니다. 객체 생성 시점에 주입을 반드시 해야지만 생성이 되기 때문에 해당 객체가 null이어서 발생할 수 있는 NPE는 발생하지 않습니다.

</details>

### IoC 컨테이너에 대해서 설명해주세요 🤔

<details>

스프링에서 객체의 생성과 의존성 관리를 책임지는 컨테이너입니다.

</details>

### AOP에 대해서 설명해주세요

<details>

어떤 로직에 대해서 핵심적인 관점과 그 외의 부가적인 관점을 분리해서 보고 각각 모듈화해서 개발하여 사용하겠다는 것입니다.
분리하게 되면 가독성이 높아지고 중복 코드를 줄이고 적용대상을 지정함으로써 유지 보수성이 높아지게 되고 모듈의 수정이 필요할 때 기존 소스 코드 변경 없이 변경과 확장이 가능하다.

</details>

### DI에 대해서 설명해주세요

<details>

의존성 주입은 클래스들이 직접 참조를 가지는 것이 아니라 외부에서 두 클래스 간의 관계를 결정해주는 것을 말합니다. 즉, 구체적인 객체를 주입받는 것이 아니라 인터페이스로 두어 런타임 시에 동적으로 관계를 주입하여 유연한 관계를 가질 수 있게 하는 것을 말합니다.

</details>

### Autowired에 대해서 설명해주세요

<details>

의존성 주입을 할 때 사용하는 어노테이션으로 의존하는 객체, 즉 빈을 찾아서 주입하는 역할을 해준다.

</details>

### Spring MVC 동작 과정에 대해서 설명해주세요

<details>

요청이 들어오게 되면 제일 처음 DispatcherServlet이 받게 되고 공통된 로직 인증 관련, 인코딩, 로깅 작업을 처리한 후 핸들러 매핑에게 요청해야 할 컨트롤러 이름에 대해서 알게 된 다음 해당 컨트롤러에게 작업을 위임하게 됩니다. 컨트롤러는 받아서 요청에 대한 로직을 DB를 포함한 비즈니스 로직을 처리한 다음 결과를 컨트롤러에게 보내주게 됩니다. 받고 나서 API 서버라면 그대로 응답 요청을 만들어 전달하게 되고 그렇지 않고 뷰를 만들어야 한다면 컨트롤러에서 뷰에 전달할 객체 model과 뷰 이름을 디스패처서블릿에게 전달합니다. 디스패처서블릿은 뷰 이름을 뷰 리졸버에게 주고 뷰 객체를 받아 아까 받은 model 객체의 데이터와 함께 화면을 렌더링을 수행해 사용자에게 전달하게 됩니다.

</details>

### DAO에 대해서 설명해주세요

<details>

데이터베이스에 접근하기 위한 전용 객체입니다. 이 객체는 WAS 로딩 시에 일정량의 DAO가 커넥션 풀에 생성되게 되게 됩니다.

</details>

### DTO, VO에 대해서 설명해주세요

<details>

둘 다 컨트롤러, 비즈니스 계층, 영속 계층들과 같이 계층 사이에서 데이터를 교환하려고 할 때 사용하는 자바 객체를 말합니다.
이 둘이 차이점은 읽기 전용이냐 아니냐에 대한 차이점입니다. 즉 변경 가능하냐 아니냐라는 말인데 DTO는 변경이 가능한 반면 VO는 변경이 불가능합니다. 이때 불가능하다는 말은 변경을 막았다는 것이 아니라 변경을 하지 않는 객체로 쓴다는 불변성을 보장한다는 룰입니다.

</details>  

### 서블릿(Servlet)에 대해서 설명해주세요

<details>

동적 웹 페이지를 만들 때 사용되는 자바 기반의 웹 애플리케이션 기술입니다. 웹을 만들 때는 다양한 요청 그리고 그에 따른 다양한 응답이 있고 거기에는 규칙이 존재하게 됩니다.
이러한 요청과 응답을 일일이 맞춰서 처리하기는 어렵지만, 서블릿을 사용하면 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해주는 기술입니다.

</details>

### 서블릿 컨테이너에 대해서 설명해주세요

<details>

서블릿 컨테이너는 서블릿을 담고 관리해주는 컨테이너입니다. 서블릿 컨테이너는 구현되어 있는 servlet 클래스의 규칙에 맞게 서블릿을 관리해주고 클라이언트에서 요청을 하면 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성하며 post, get 여부에 따라 동적인 페이지를 생성하여 응답을 보냅니다.

</details>

### 서블릿 동작 과정에 대해서 설명해주세요

<details>

사용자가 요청을 보내게 되면 HTTP Request가 서블릿 컨테이너로 전송되게 됩니다. 요청을 받은 서블릿 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성합니다. 설정 파일을 기반으로 매핑할 서블릿을 찾고 인스턴스가 없으면 init 메서드를 이용해 생성하고 다음으로 서블릿 컨테이너에서 스레드를 생성하고 service를 실행합니다.
응답까지 처리가 끝났다면 destory 메서드를 실행하여 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.

</details>

### 프론트 컨트롤러 패턴에 대해서 설명해주세요

<details>

사용자의 요청이 원래는 각각의 구체적인 컨트롤러에게 전달되었지만 그렇게 하지 않고 구체적인 컨트롤러들 앞에 프론트 컨트롤러를 하나 두어 모든 요청을 받아내고 공통 로직을 처리한 후에 구체적인 컨트롤러에 작업을 위임하는 형태를 말합니다.
이렇게 하면 기존에 서블릿마다 공통된 로직을 중복 작성해야 한다는 비효율적인 측면을 해결할 수 있고 관리하기 편해집니다.
스프링에서 프론트 컨트롤러 패턴의 역할을 하는 것으로 DispatcherServlet이 있습니다.

</details>

### DispatcherServlet에 대해서 설명해주세요

<details>

HTTP 프로토콜을 통해서 들어오는 모든 요청을 앞에서 처리하는 프론트 컨트롤러입니다. 이는 앞에서 모든 요청을 받고 공통 처리 작업 인코딩, 로깅, 인증 관련 처리 등을 처리한 후에 세부적인 컨트롤러로 작업을 위임해줍니다.

</details>

### Filter와 Interceptor에 차이점에 대해 설명해주세요

<details>

Filter와 Interceptor의 차이점은 적용 시점인데 Filter는 디스패처서블릿 전/후로 인터셉터는 컨트롤러 전/후로 작업을 처리합니다. 그리고 관리되는 컨테이너가 필터는 웹 컨테이너 그리고 인터셉터는 스프링 컨테이너에서 관리되게 됩니다.

</details>

### 스프링에서 에러를 처리하는 방법에 대해서 설명해주세요

<details>

ExceptionHandler를 어노테이션으로 이용하게 되면 컨트롤러 메서드에 붙여 각각의 요청에 세부 예외 처리를 매우 유연하게 처리할 수 있게 할 수 있습니다.
그리고 ControllerAdvice 어노테이션을 이용하면 전역적으로 발생하는 글로벌 예외를 처리할 수 있습니다.

</details>